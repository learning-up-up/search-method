# 博弈搜索

## 博弈树

###  极小极大化搜索

将博弈双方先手与后手分别抽象为max节点与min节点（max类似于或节点，min类似于与节点），将游戏结果抽象为
```math
value = \begin{cases}
            1 & \text{if\,\,先手胜} \\
            0 & \text{if\,\,平局} \\
            -1 & \text{if\,\,后手胜}
        \end{cases}
```

对于max节点，每一步都应当在子节点中选择最大值节点，对于min节点选择策略是相反的

依次我们的程序可分为这样几步：

* ~~扩展节点~~
* ~~计算叶子节点的值~~
* ~~反向赋值~~

编者在这里出现了很大的问题，事实上我们根本无需事先完全扩展所有节点，这样的内存消耗是巨大的，这一导致了一开始我们的方法需要十几分钟才能得到结果。事实上我们应该在赋值的过程中***按需递归***展开，这样可以极大地节省内存空间，对于底层的节点我们边用边扔。


我们通过这种方式来模拟井字棋游戏，对于N宫格，其代码的复杂度为$`O(n!)`$。经过代码验证，而可以得到扩展次数为$`986410`$次

我们可以看到，这个思路是可行的，但仅仅是九宫格问题，复杂度就已经很高了，对于更复杂的博弈问题（如国际象棋与围棋），就有些困难了。因此，我们要进行优化

### alpha-beta剪枝

对于minmax搜索，我们实际上是完全展开了博弈树，事实上对于博弈双方而言有很多节点无需进行过多扩展，就可以直接放弃。如：

基于alpha-beta剪枝的基本原理，我们对于原生的search()方法进行优化：
```python
def alpha_beta_search(self) -> None:
    searched_nodes = 0

    def alpha_beta(node: Node, alpha: float, beta: float) -> float:
        nonlocal searched_nodes
        searched_nodes += 1
        node.expand_node()
        if node.is_terminal:
            node.value = node.evaluate()
            return node.value

        if node.catgory == "max":
            value = float('-inf')
            for child in node.children:
                value = max(value, alpha_beta(child, alpha, beta))
                alpha = max(alpha, value)
                if alpha >= beta:
                    break
            node.value = value
            return value

        else:
            value = float('inf')
            for child in node.children:
                value = min(value, alpha_beta(child, alpha, beta))
                beta = min(beta, value)
                if alpha >= beta:
                    break
            node.value = value
            return value

    best_value = alpha_beta(self.root, float('-inf'), float('inf'))

    print(f"best value: {best_value}")
    print(f"searched nodes: {searched_nodes}")   
```

在剪枝的优化下，我们再进行关于井字棋游戏，这一次只要$`18937`$就得到了结果。