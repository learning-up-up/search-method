# 博弈搜索

## 博弈树

###  极小极大化搜索

将博弈双方先手与后手分别抽象为max节点与min节点（max类似于或节点，min类似于与节点），将游戏结果抽象为
```math
value = \begin{cases}
            1 & \text{if\,\,先手胜} \\
            0 & \text{if\,\,平局} \\
            -1 & \text{if\,\,后手胜}
        \end{cases}
```

对于max节点，每一步都应当在子节点中选择最大值节点，对于min节点选择策略是相反的

依次我们的程序可分为这样几步：

* 扩展节点
* 计算叶子节点的值
* 反向赋值

我们通过这种方式来模拟井字棋游戏，对于N宫格，其代码的复杂度为$O(n!)$。经过代码验证，而可以得到扩展次数为$986410$次（如果你的电脑不那么快，请耐心等到，代码是可靠的）

我们可以看到，这个思路是可行的，但仅仅是九宫格问题，复杂度就已经很高了，对于更复杂的博弈问题（如国际象棋与围棋），就有些困难了。因此，我们要进行优化